;;current_co = connection_option(player, "hold-input"); try   set_connection_option(player, "hold-input", 1);   the_parent = `$mcp.package ! ANY => #-3';   the_object = player:_create(the_parent);   some_wizard = verb_info($wiz_utils, "set_player")[1];   some_player = $hacker;   okay = 0;   if (typeof(the_parent) != OBJ)     player:tell("$mcp.package is not an object.");     verb_code = {       "player:tell(\"-ERR : Parent not found, ignoring line.\");"     };   elseif (the_parent == #-3)     player:tell("$mcp.package is not a valid object on this MOO.");     verb_code = {       "player:tell(\"-ERR : Parent not found, ignoring line.\");"     };   elseif (!player.wizard)     player:tell("You need wizardly permissions to use this installer.");     verb_code = {       "player:tell(\"-ERR : Insufficient permissions, ignoring line.\");"     };   else     okay = 1;     verb_code = {        "if (player != this)",        "  return raise(E_PERM);",        "endif",        "current_co = connection_option(player, \"hold-input\");",       "try",       "  set_connection_option(player, \"hold-input\", 1);",       "  argstr = $string_utils:substitute(argstr, {",        "              { \"__OBJECT_133652567__\", tostr(the_object) }",       "              , { \"__PARENT_133652567__\", tostr(the_parent) }",        "              , { \"__WIZARD_133652567__\", tostr(some_wizard) }",        "              , { \"__PLAYER_133652567__\", tostr(some_player) }",        "           });",       "  try",       "    { ok, result} = eval(argstr);",       "  except error (ANY)",       "    { ok, result } = { 0, tostr(\"ERR : \", toliteral(error)) };",       "  endtry",       "  if (!ok)",       "    player:tell(\"-ERR : \", toliteral(result));",       "  else",       "    player:tell(\"+OK : Processed line\");",       "  endif",       "finally",       "  set_connection_option(player, \"hold-input\", current_co);",       "endtry"     };    endif   if (!okay)     player:tell("Ignoring the rest of the input. Prepare for spam...");     if (typeof(the_object) == OBJ && valid(the_object))       player:_recycle(the_object);     endif   else     `move(the_object, player) ! ANY';   endif   add_verb(      player,      { player, "d", "@temp_program_133652567" },      { "any", "any", "any" }   );   for i in [1..length(verb_code)]      verb_code[i] = $string_utils:substitute(        verb_code[i], {          { "the_object", tostr(the_object) } ,          { "the_parent", tostr(the_parent) } ,          { "some_player", tostr(some_player) } ,          { "some_wizard", tostr(some_wizard) }        }     );   endfor   set_verb_code(player, "@temp_program_133652567", verb_code); finally   set_connection_option(player, "hold-input", current_co); endtry
@temp_program_133652567 `add_property(__OBJECT_133652567__, "help_msg", {}, { __PLAYER_133652567__, "rc"}) ! ANY';
@temp_program_133652567 __OBJECT_133652567__:set_name("dns-com-vmoo-smartcomplete");
@temp_program_133652567 __OBJECT_133652567__:set_aliases({"dns-com-vmoo-smartcomplete", "cc", "sc"});
@temp_program_133652567 add_property(__OBJECT_133652567__, "direct_commands", 0, {__PLAYER_133652567__, "r"});
@temp_program_133652567 __OBJECT_133652567__.("direct_commands") = {"@edit", "@program", ".program", "@rename", "@rmverb", "@args", "@chmod"};
@temp_program_133652567 add_property(__OBJECT_133652567__, "max_verbs", 0, {__PLAYER_133652567__, "r"});
@temp_program_133652567 __OBJECT_133652567__.("max_verbs") = 192;
@temp_program_133652567 `__OBJECT_133652567__.("key") = 0 ! ANY';
@temp_program_133652567 `__OBJECT_133652567__.("description") = "VMoo MCP Command Completion Module. See 'help dns-com-vmoo-commandcomplete' for more info." ! ANY';
@temp_program_133652567 `__OBJECT_133652567__.("object_size") = {23479, 975879180} ! ANY';
@temp_program_133652567 `__OBJECT_133652567__.("help_msg") = {"------------------------------------------------------------------------------", "Package:  dns-com-vmoo-commandcomplete ", "Version:  1.0", "Date:     November 2000", "Author:   Pieter-Bas IJdens ( Pieter-Bas @ telnet://parkmoo.dds.nl:7777 )", "------------------------------------------------------------------------------", "", "", "HISTORY", "------------------------------------------------------------------------------", "  Version 1.0  -  First release", "", "", "INSTALLATION", "------------------------------------------------------------------------------", "  Like any other MCP package, register it in the $mcp package registry.", "", "", "PROPERTIES", "------------------------------------------------------------------------------", "  .direct_commands :: { STR command }", "    List of commands that for verb completion only return those verbs that ", "    are defined directky on the object. Examples are @edit, @program and", "    .program that don't work on verbs on ancestors. Other verbs like @list,", "    @display etc. can work on verbs on ancestors as well.", "", "", "PROTOCOL:", "------------------------------------------------------------------------------", "", "Handled messages:", "", "* C->M: dns-com-vmoo-smartcomplete-request(id, prefix, suffix, channel)", "", "    id      : Request identifier, must be returned with the reponse", "    prefix  : Text before the cursor", "    suffix  : Text after the cursor", "    channel : Channel-id, used for multi-window mode (not used)", "", "Sent messages:", "", "* M->C: dns-com-vmoo-smartcomplete-result(id, startpos, deluntil, options*)", "", "    id       : the id that was received upon request", "    startpos : position (0..length) in the prefix. the client must keep this", "               many characters in the prefix, and relace the rest, when using", "               one of the suggested options.", "    deluntil : position (0..length) in the suffix until where the result ", "               overwrites characters in the suffix.", "    options  : the possible options for this completion. When no options exist,", "               startpos and endpos shall indicate length(prefix) and 0, and", "               a single empty string shall be returned as the only option.", "", "", "KNOWN ISSUES", "------------------------------------------------------------------------------", "  Version 1.0 does actively not support eval (';' and 'eval') completion.", "", "", "LINKS", "------------------------------------------------------------------------------", "  Author:     mailto:mcp-info@monad.freeserve.co.uk", "              http://members.chello.nl/~p.ijdens/", "  VMoo:       http://www.vmoo.com/", ""} ! ANY';
@temp_program_133652567 `__OBJECT_133652567__.("messages_in") = {{"request", {"id", "prefix", "suffix", "channel"}}} ! ANY';
@temp_program_133652567 `__OBJECT_133652567__.("messages_out") = {{"result", {"id", "startpos", "deluntil", "options"}}} ! ANY';
@temp_program_133652567 `__OBJECT_133652567__.("version_range") = {"0.0", "1.0"} ! ANY';
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","send_result"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","handle_request"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_complete"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_complete_eval"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_complete_command"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_complete_arguments"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_find_verbs_with_name"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__WIZARD_133652567__,"rxd","_all_verbs_for"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","init_for_core init_for_package"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_find_players_with_name"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_find_mailinglists_with_name"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__WIZARD_133652567__,"rxd","_find_properties_with_name"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_find_objects_with_name"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_all_verb_names"}, {"this", "none", "this"});
@temp_program_133652567 add_verb(__OBJECT_133652567__,{__PLAYER_133652567__,"rxd","_kill_regexp_chars"}, {"this", "none", "this"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,1,{"\"@proto     :send_result(session,id, keep_in_prefix, drop_from_suffix, { STR option })\";", "\"           :send_result(session, id, keep_in_prefix, drop_from_suffix, \\\"\\\")\";", "\"\";", "\"@memo      Sends a result of a 'request' action back to the client.\";", "\"\";", "\"@doc       Used to send the result of a client-request back to the client.\";", "\"           Works by virtue of the <parent>:send_* verb and the result\";", "\"           tuple in <this>.messages_out.\";", "if (caller != this)", "  return E_PERM;", "endif", "{session, @args} = args;", "return pass(session, @args);", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 09:53:40 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,2,{"\"@proto     :handle_request(session, id, prefix, suffix, channel)\";", "\"\";", "\"@memo      Handler for 'dns-com-vmoo-commandcomplete-request' messages\";", "\"\";", "\"@doc       Handles inoming 'dns-com-vmoo-commandcomplete-request' messages by\";", "\"           virtue of the parent and the 'request' entry in the messages_in\";", "\"           property.\";", "if (caller != this)", "  return E_PERM;", "endif", "{session, id, prefix, suffix, channel} = args;", "who = session.connection;", "result = this:_complete(who, prefix, suffix, channel);", "this:send_result(session, id, @result);", "return 0;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 09:58:38 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,3,{"\"@proto     :_complete(who, prefix, suffix, client)\";", "\"\";", "\"@return    { keep_in_prefix, drop_from_suffix, { STR option, ... } }\";", "\"@return    { length(prefix), 0, \\\"\\\" }\";", "\"\";", "\"@memo      Completes your command line, given 'prefix' and 'suffix'\";", "\"\";", "\"@doc       Takes the text in 'prefix' as the text before the cursor and\";", "\"           the text in 'suffix' as the text after the cursor and completes\";", "\"           the command line based on that info. Returns a list of options\";", "\"           and the amount of data to be replaced from either side. If\";", "\"           no match is found, returns an empty string instead of options.\";", "if (!$perm_utils:controls(caller_perms(), this) && caller != this)", "  return raise(E_PERM);", "endif", "{who, prefix, suffix, client} = args;", "result = 0;", "result = result || this:_complete_eval(@args);", "result = result || this:_complete_command(@args);", "result = result || this:_complete_arguments(@args);", "if (!result)", "  result = {length(prefix), 0, \"\"};", "endif", "return result;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:05:08 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,4,{"\"@proto     :_complete_eval(who, prefix, suffix, target)\";", "\"\";", "\"@return    { keep_in_prefix, keep_in_suffix, { STR option, STR * } }\";", "\"           indicates there are matches\";", "\"\";", "\"@return    { keep_in_prefix, keep_in_suffix, \\\"\\\" }\";", "\"           indicates the prefix is matched by this function, but there are no\";", "\"           options\";", "\"\";", "\"@return    0\";", "\"           indicates the (prefix,suffix) could not be completed by this\";", "\"           function\";", "\"\";", "\"@memo      Takes (prefix,suffix) and attempts to complete it\";", "\"\";", "\"@doc       Given (prefix,suffix) attempts completion. If this could be done,\";", "\"           returns he results (if any), otherwise returns a value that indicates\";", "\"           the function could do nothing with the input.\";", "if (caller != this)", "  return raise(E_PERM);", "endif", "{who, prefix, suffix, target} = args;", "\"/*\";", "\" * attempt to match an eval\";", "\" */\";", "if (match(prefix, \"^[ ]*%(eval%|;%)[ ]+%(.*%)$\"))", "  \"/*\";", "  \" * Attempt to find the 'last part' of the eval.\";", "  \" * This is everyting after the last open bracket,\";", "  \" * everything after the last ,space,\";", "  \" * or, everything after the last semicolon\";", "  \" */\";", "  \"***\";", "  \"*** TBD (now we know it is an eval, ignore it...)\";", "  \"***\";", "  return {length(prefix), 0, \"\"};", "endif", "return 0;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:09:01 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,5,{"\"@proto     :_complete_command(who, prefix, suffix, target)\";", "\"\";", "\"@return    { keep_in_prefix, keep_in_suffix, { STR option, STR * } }\";", "\"           indicates there are matches\";", "\"\";", "\"@return    { keep_in_prefix, keep_in_suffix, \\\"\\\" }\";", "\"           indicates the prefix is matched by this function, but there are no\";", "\"           options\";", "\"\";", "\"@return    0\";", "\"           indicates the (prefix,suffix) could not be completed by this\";", "\"           function\";", "\"\";", "\"@memo      Takes (prefix,suffix) and attempts to complete it\";", "\"\";", "\"@doc       Given (prefix,suffix) attempts completion. If this could be done,\";", "\"           returns he results (if any), otherwise returns a value that indicates\";", "\"           the function could do nothing with the input.\";", "if (caller != this)", "  return raise(E_PERM);", "endif", "{who, prefix, suffix, target} = args;", "\"/*\";", "\" * Only focusses on the command part of the command-line.\";", "\" * If ther are arguments, does not match the line.\";", "\" */\";", "if (match = match(prefix, \"^[ ]*%([^ ]*%)$\"))", "  {from, to} = match[3][1];", "  regexp = \"%( %|^%)\" + this:_kill_regexp_chars(prefix[from..to]);", "  objects = {who, who.location, @`who.location.contents ! ANY => {}', @who.contents, @`who.features ! ANY => {}'};", "  verbs = this:_find_verbs_with_name(who, regexp, objects);", "  if (verbs)", "    return {from - 1, 0, $list_utils:slice(verbs, 2)};", "  else", "    return {length(prefix), 0, \"\"};", "  endif", "endif", "return 0;", "\"LMB #5000 (Pieter-Bas) Thu Nov 30 18:51:31 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,6,{"\"@proto     :_complete_arguments(who, prefix, suffix, target)\";", "\"\";", "\"@return    { keep_in_prefix, keep_in_suffix, { STR option, STR * } }\";", "\"           indicates there are matches\";", "\"\";", "\"@return    { keep_in_prefix, keep_in_suffix, \\\"\\\" }\";", "\"           indicates the prefix is matched by this function, but there are no\";", "\"           options\";", "\"\";", "\"@return    0\";", "\"           indicates the (prefix,suffix) could not be completed by this\";", "\"           function\";", "\"\";", "\"@memo      Takes (prefix,suffix) and attempts to complete it\";", "\"\";", "\"@doc       Given (prefix,suffix) attempts completion. If this could be done,\";", "\"           returns he results (if any), otherwise returns a value that indicates\";", "\"           the function could do nothing with the input.\";", "if (caller != this)", "  return raise(E_PERM);", "endif", "{who, prefix, suffix, target} = args;", "if (index(prefix, \" \"))", "  \"/*\";", "  \" * attempt to parse the string\";", "  \" */\";", "  \"speed over accuracy...\";", "  keep_in_prefix = length(prefix);", "  drop_in_suffix = 0;", "  options = {};", "  {command, @_, ?last_arg = \"\"} = $string_utils:words(prefix);", "  if (!last_arg)", "    \"/*\";", "    \" * ignore it, too much work\";", "    \" */\";", "  elseif (match(last_arg, \"^#[0-9]+$\"))", "    \"/*\";", "    \" *  it's an object number, which means you are on your own.\";", "    \" */\";", "  elseif (match = match(last_arg, \"^%(.*%)[:]%([^:]*%)$\"))", "    \"/*\";", "    \" *  it's a verb\";", "    \" */\";", "    obj_name = last_arg[match[3][1][1]..match[3][1][2]];", "    partial_verbname = last_arg[match[3][2][1]..match[3][2][2]];", "    keep_in_prefix = keep_in_prefix - (length(last_arg) - match[3][2][1]) - 1;", "    object = player:my_match_object(obj_name);", "    if (valid(object))", "      if (command in this.direct_commands)", "        \"/*\";", "        \" * The command only works on verbs on the specified object itself.\";", "        \" */\";", "        regexp = regexp = \"%( %|^%)\" + this:_kill_regexp_chars(partial_verbname);", "        all_verbs = this:_all_verbs_for(who, object, regexp);", "        for v in (all_verbs)", "          if (match(v, regexp))", "            options = {@options, v};", "          endif", "        endfor", "      else", "        \"/*\";", "        \" * The command works on verbs on the specified object itself and its\";", "        \" * ancestors.\";", "        \" */\";", "        regexp = regexp = \"%( %|^%)\" + this:_kill_regexp_chars(partial_verbname);", "        options = {@options, @$list_utils:slice(this:_find_verbs_with_name(who, regexp, {object}, 0), 2)};", "      endif", "    endif", "  elseif (match = match(last_arg, \"^%(.*%)[.]%([^.]*%)$\"))", "    \"/*\";", "    \" *  it's a property\";", "    \" */\";", "    obj_name = last_arg[match[3][1][1]..match[3][1][2]];", "    partial_propname = last_arg[match[3][2][1]..match[3][2][2]];", "    object = player:my_match_object(obj_name);", "    keep_in_prefix = keep_in_prefix - (1 + length(last_arg) - match[3][2][1]);", "    if (valid(object))", "      options = {@options, @this:_find_properties_with_name(who, object, partial_propname)};", "    endif", "  elseif (match = match(last_arg, \"^~.*$\"))", "    \"/*\";", "    \" *  it's a player\";", "    \" */\";", "    partial_name = last_arg[2..$];", "    keep_in_prefix = keep_in_prefix - (length(last_arg) - 1);", "    options = {@options, @this:_find_players_with_name(partial_name)};", "  elseif (match = match(last_arg, \"^[*].*$\"))", "    \"/*\";", "    \" *  it's a mailing list\";", "    \" */\";", "    partial_name = last_arg[2..$];", "    keep_in_prefix = keep_in_prefix - (length(last_arg) - 1);", "    options = {@options, @this:_find_mailinglists_with_name(partial_name)};", "  else", "    \"/*\";", "    \" *  it's an object\";", "    \" */\";", "    keep_in_prefix = keep_in_prefix - length(last_arg);", "    partial_name = last_arg;", "    options = {@options, @this:_find_objects_with_name(who, partial_name)};", "  endif", "  \"/*\";", "  \" *  return the results\";", "  \" */\";", "  return {keep_in_prefix, drop_in_suffix, options ? options | \"\"};", "endif", "return 0;", "\"LMB #5000 (Pieter-Bas) Tue Nov 28 12:59:03 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,7,{"\"@proto       _find_verbs_with_name(OBJ who, STR regexp, LIST objects, [BOOL cline = true])\";", "\"\";", "\"@memo        Lists all verbs on the objects matching the specified regexp.\";", "\"\";", "\"@doc         Given a set of objects, searches the objects and all their\";", "\"             ancestors for verbs matching the specified regular\";", "\"             expression. If cline is false, does not ignore all verbs that\";", "\"             cannot be called from the command-line.\";", "\"\";", "\"@return      LIST of { OBJ obj, STR verbname }\";", "\"             List of matching verbs, and their object number (if you don't\";", "\"             care, $list_utils:slice(@_, x) takes only a hundred-something\";", "\"             ticks for a long list.\";", "if (caller != this)", "  return raise(E_PERM);", "endif", "{who, regexp, objects, ?only_cline = 1} = args;", "result = {};", "process_objects = {};", "\"ugly code, but faster than {@x, o, @ancestors(o)}\";", "for o in (objects)", "  process_objects = setadd(process_objects, o);", "  for ancestor in ($object_utils:ancestors(o))", "    process_objects = setadd(process_objects, ancestor);", "  endfor", "endfor", "for o in (process_objects)", "  options = valid(o) ? this:_all_verbs_for(who, o, regexp) | {};", "  for vrbname in (options)", "    clean_name = strsub(vrbname, \"*\", \"\");", "    if (match(clean_name, regexp))", "      {_d, _p, _i} = `verb_args(o, clean_name) ! ANY => {\"this\", \"none\", \"this\"}';", "      if (!only_cline || _p != \"none\" || _d == \"none\" || _i == \"none\")", "        result = setadd(result, {o, clean_name});", "        if (index = index(vrbname, \"*\"))", "          result = setadd(result, {o, vrbname[1..index - 1]});", "        endif", "        if (this.max_verbs && length(result) >= this.max_verbs)", "          result = setadd(result, {#-1, tostr(\" (limited to \", this.max_verbs, \" matches) \")});", "          break o;", "        endif", "      endif", "    endif", "    $command_utils:suspend_if_needed(0);", "  endfor", "endfor", "return result;", "\"LMB #5000 (Pieter-Bas) Mon Nov 20 16:41:12 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,8,{"\"@x-status  *WIZARDLY*\";", "\"           Needs wizard-perms to allow the verb to return all verbs accessible\";", "\"           by the specified player. Can do without perms if needed, but does\";", "\"           not include all options in that case.\";", "\"\";", "\"@proto     _all_verbs_for(OBJ who, OBJ object, [ STR regexp = \\\"\\\" ])\";", "\"\";", "\"@return    { STR name, ...}\";", "\"           List of matching/all names.\";", "\"\";", "\"@memo      Get a full list of (matching) verbs\";", "\"\";", "\"@doc       Searches a single object, and returns a list with all the verbs\";", "\"           that have been defined on that object, and that can be read by\";", "\"           the identified player.\";", "if (caller != this)", "  return raise(E_PERM);", "endif", "{who, object, ?regexp = \"\"} = args;", "set_task_perms(who);", "result = {};", "for vrbdef in (`verbs(object) ! E_PERM => {}')", "  if (typeof(vrbdef) == STR && (!regexp || match(strsub(vrbdef, \"*\", \"\"), regexp)))", "    $command_utils:suspend_if_needed(0);", "    options = this:_all_verb_names(vrbdef);", "    for vrbname in (options)", "      result = setadd(result, vrbname);", "    endfor", "  endif", "endfor", "return result;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:43:54 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,9,{"\"@proto     init_for_core()\";", "\"\";", "\"@memo      Initializes the object for in a core-database.\";", "\"\";", "\"@doc       Re-initializes and cleans the object during the creation\";", "\"           of a core database.\";", "if (!$perm_utils:controls(caller_perms(), this))", "  return raise(E_PERM);", "endif", "return 0;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:44:49 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,10,{"\"@proto     :_find_players_with_names(partial_name)\";", "\"\";", "\"@return    { STR name, ... }\";", "\"           list of possible names.\";", "\"\";", "\"@memo      Finds all registered players with a matching name\";", "\"\";", "\"@doc       Searches the player database for all players that have\";", "\"           a name that starts with the specified prefix (partial_name).\";", "{partial_name} = args;", "options = {};", "players = $player_db:find_all(partial_name);", "for candidate in (players)", "  if (index(candidate.name, partial_name) == 1)", "    options = setadd(options, candidate.name);", "  endif", "endfor", "return options;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:46:45 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,11,{"\"@proto     :_find_mailinglists_with_names(partial_name)\";", "\"\";", "\"@return    { STR name, ... }\";", "\"           list of possible names.\";", "\"\";", "\"@memo      Finds all registered mailing lists with a matching name\";", "\"\";", "\"@doc       Searches the mail distribution centre for all lists that have\";", "\"           a name that starts with the specified prefix (partial_name).\";", "\"           Also returns all matching aliases.\";", "{partial_name} = args;", "options = {};", "lists = $mail_agent.contents;", "names = {};", "for l in (lists)", "  names = {@names, l.name, @l.aliases};", "endfor", "for candidate_name in (names)", "  if (index(candidate_name, partial_name) == 1)", "    options = setadd(options, candidate_name);", "  endif", "endfor", "return options;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:49:11 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,12,{"\"@x-status  *WIZARDLY*\";", "\"           Needs wizard-perms to allow the verb to return all properties accessible\";", "\"           by the specified player. Can do without perms if needed, but does\";", "\"           not include all options in that case.\";", "\"\";", "\"@proto     :_find_properties_with_names(who, object, prefix)\";", "\"\";", "\"@return    { STR name, ... }\";", "\"           list of possible names.\";", "\"\";", "\"@memo      Finds all accessible properties on the specified object.\";", "\"\";", "\"@doc       Searches the specified object and all its ancestors for properties\";", "\"           matching the specified name.\";", "if (caller != this)", "  return raise(E_PERM);", "endif", "{who, object, prefix} = args;", "set_task_perms(who);", "names = `$object_utils:all_properties(object) ! ANY => {}';", "options = {};", "for candidate_name in (names)", "  if (index(candidate_name, prefix) == 1)", "    options = setadd(options, candidate_name);", "  endif", "endfor", "return options;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:50:55 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,13,{"\"@proto     :_find_objects_with_names(partial_name)\";", "\"\";", "\"@return    { STR name, ... }\";", "\"           list of possible names.\";", "\"\";", "\"@memo      Finds all objects with a matching name\";", "\"\";", "\"@doc       Searches the player and its direct environment for objects.\";", "\"           matching the specified name. Typically returns only objects\";", "\"           that can be used as an argument to player:my_match_object()\";", "\"           and then resolve properly.\";", "{who, partial_name} = args;", "options = {};", "objects = {who, @who.contents, @`who.location.contents ! ANY => {}'};", "for candidate in (objects)", "  if (index(candidate.name, partial_name) == 1)", "    options = setadd(options, candidate.name);", "  endif", "endfor", "return options;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:53:47 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,14,{"\"@proto     :_all_verb_names(STR complete_name)\";", "\"\";", "\"@return    { STR name, ... }\";", "\"           List of names\";", "\"\";", "\"@memo      Breaks up a verb name in aliases\";", "\"\";", "\"@doc       Splits up a verb name into single aliases. Faster than\";", "\"           $string_utils:words() because it need not check for quotes.\";", "{verbdef} = args;", "result = {};", "while (verbdef)", "  if (i = index(verbdef, \" \"))", "    result = setadd(result, verbdef[1..i - 1]);", "    verbdef = verbdef[i + 1..$];", "  else", "    result = setadd(result, verbdef);", "    verbdef = \"\";", "  endif", "endwhile", "return result;", "\"LMB #5000 (Pieter-Bas) Thu Nov 16 10:55:36 2000 MET\";"});
@temp_program_133652567 set_verb_code(__OBJECT_133652567__,15,{"{outstr, ?kill_star = 1} = args;", "recre = \"%([.*^$%+]%|%]%)\";", "if (match(outstr, recre))", "  outstr = strsub(outstr, \"%\", \"%%\");", "  outstr = strsub(outstr, \"^\", \"%^\");", "  outstr = strsub(outstr, \"$\", \"%$\");", "  outstr = strsub(outstr, \"[\", \"%[\");", "  outstr = strsub(outstr, \"]\", \"%]\");", "  outstr = strsub(outstr, \".\", \"%.\");", "  outstr = strsub(outstr, \"+\", \"%+\");", "  kill_star && (outstr = strsub(outstr, \"*\", \"\"));", "endif", "return outstr;", "\"LMB #5000 (Pieter-Bas) Thu Nov 30 18:52:32 2000 MET\";"});
@temp_program_133652567 player:tell("Now type '@add-package __OBJECT_133652567__ to ",$mcp.registry,"' to register it as MCP package.");
;;delete_verb(player, "@temp_program_133652567"); 
